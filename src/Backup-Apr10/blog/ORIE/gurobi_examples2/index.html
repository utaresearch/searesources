<!DOCTYPE html>
<html lang="en" dir="ltr"><head>
  
                           
     


<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.91.2" />
<title>Gurboi&#39;s R Examples 2 | Erick C. Jones Jr.</title>








  
    
  
<meta name="description" content="The personal and lab website for Erick C. Jones Jr..">


<meta property="og:site_name" content="Erick C. Jones Jr.">
<meta property="og:title" content="Gurboi&#39;s R Examples 2 | Erick C. Jones Jr.">
<meta property="og:description" content="The personal and lab website for Erick C. Jones Jr.." />
<meta property="og:type" content="page" />
<meta property="og:url" content="/blog/orie/gurobi_examples2/" />
<meta property="og:locale" content="en">




    
        <meta property="og:image" content="/blog/sidebar-listing.jpg" >
        <meta property="twitter:card" content="summary_large_image">
        <meta name="twitter:image" content="/blog/sidebar-listing.jpg" >
    
    
  <meta itemprop="name" content="Gurboi&#39;s R Examples 2">
<meta itemprop="description" content="This post explores how to use Gurobi to solve more advanced LPs, MIPs, and QPs.I have written these using Gurobi as a solver and as the mathematical formulation software.This is a reproducible example if you have R Studio just make sure you have installed the correct packages.
library(gurobi)## Warning: package &#39;gurobi&#39; was built under R version 4.0.2library(Matrix)This example formulates and solves the following simple QP model:"><meta itemprop="datePublished" content="2020-01-06T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-01-06T00:00:00+00:00" />
<meta itemprop="wordCount" content="5086">
<meta itemprop="keywords" content="R Markdown,QP,Gurboi,Algorithms," />
  
  
  <!--[if IE]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="shortcut icon" href="/img/favicon1.ico" type="image/x-icon">
  <link rel="icon" href="/img/favicon1.ico" type="image/x-icon">
  
  
  <link rel="stylesheet" href="/style.main.min.5477c20f89738a32763391bbc2f43dbdfc2db0e7faba550c86cac92c99efa6b6.css" integrity="sha256-VHfCD4lzijJ2M5G7wvQ9vfwtsOf6ulUMhsrJLJnvprY=" media="screen">
  
  
  <script src="/panelset.min.078a92db9bd3228df502db3d9e0453c3cf3d910abe3f8deca0ad196c7071ad41.js" type="text/javascript"></script>
  
  
  <script src="/main.min.2e8249bbdd5d578b176fda15faa5570d1164bf672531c811ea0fe65e5f4ac87a.js" type="text/javascript"></script>
</head>
<body>
      <div class="grid-container">
<header class="site-header pt4 pb2 mb4 bb b--transparent ph5 headroom z-max" role="banner">
  <nav class="site-nav db dt-l w-100" role="navigation">
    <a class="site-brand db dtc-l v-mid link no-underline w-100 w-33-l tc tl-l" href="/" title="Home">
      <img src="/img/SApic.jpg" class="dib db-l h2 w-auto" alt="Erick C. Jones Jr.">
    </a>
    <div class="site-links db dtc-l v-mid w-100 w-47-l tc tr-l mt3 mt0-l ttu tracked">
      
        
        
        
      <a class="link f6 f5-l dib pv1 ph2 " href="/about/" title="About">About</a>
      
        
        
        
      <a class="link f6 f5-l dib pv1 ph2 " href="/project/" title="Project Portfolio">Projects</a>
      
        
        
        
      <a class="link f6 f5-l dib pv1 ph2 " href="/publication/" title="Publications">Publications</a>
      
        
        
        
      <a class="link f6 f5-l dib pv1 ph2 " href="/courses/" title="Courses">Courses</a>
      
        
        
        
      <a class="link f6 f5-l dib pv1 ph2 " href="/lab/" title="Lab">Lab</a>
      
        
        
        
      <a class="link f6 f5-l dib pv1 ph2 active" href="/blog/" title="Posts">Posts</a>
      
      
    </div>
  </nav>
</header>

<main class="page-main pa4" role="main">
  <section class="page-content mw7 center">
    <article class="post-content pa0 ph4-l">
      <header class="post-header">
        <h1 class="f1 lh-solid measure-narrow mb3 fw4">Gurboi&#39;s R Examples 2</h1>
        
        <p class="f6 measure lh-copy mv1">By Erick Jones in <a href="/categories/orie-techniques">ORIE Techniques</a> </p>
        <p class="f7 db mv0 ttu">January 6, 2020</p>

      

      </header>
      <section class="post-body pt5 pb4">
        
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>This post explores how to use Gurobi to solve more advanced LPs, MIPs, and QPs.
I have written these using Gurobi as a solver and as the mathematical formulation software.
This is a reproducible example if you have R Studio just make sure you have installed the correct packages.</p>
<pre class="r"><code>library(gurobi)</code></pre>
<pre><code>## Warning: package &#39;gurobi&#39; was built under R version 4.0.2</code></pre>
<pre class="r"><code>library(Matrix)</code></pre>
<p>This example formulates and solves the following simple QP model:</p>
<p><span class="math inline">\(min: x^2 + xy + y^2 + yz + z^2 + 2 x\)</span></p>
<p>subject to</p>
<pre><code>   $x + 2 y + 3z \geq 4$
   
   $x +   y      \geq 1$
   x, y, z non-negative</code></pre>
<pre class="r"><code>model &lt;- list()

model$A     &lt;- matrix(c(1,2,3,1,1,0), nrow=2, byrow=T)
model$Q     &lt;- matrix(c(1,0.5,0,0.5,1,0.5,0,0.5,1), nrow=3, byrow=T)
model$obj   &lt;- c(2,0,0)
model$rhs   &lt;- c(4,1)
model$sense &lt;- c(&#39;&gt;&#39;, &#39;&gt;&#39;)

result &lt;- gurobi(model)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 2 rows, 3 columns and 5 nonzeros
## Model fingerprint: 0xe6f007c4
## Model has 5 quadratic objective terms
## Coefficient statistics:
##   Matrix range     [1e+00, 3e+00]
##   Objective range  [2e+00, 2e+00]
##   QObjective range [2e+00, 2e+00]
##   Bounds range     [0e+00, 0e+00]
##   RHS range        [1e+00, 4e+00]
## Presolve time: 0.00s
## Presolved: 2 rows, 3 columns, 5 nonzeros
## Presolved model has 5 quadratic objective terms
## Ordering time: 0.00s
## 
## Barrier statistics:
##  Free vars  : 2
##  AA&#39; NZ     : 6.000e+00
##  Factor NZ  : 1.000e+01
##  Factor Ops : 3.000e+01 (less than 1 second per iteration)
##  Threads    : 1
## 
##                   Objective                Residual
## Iter       Primal          Dual         Primal    Dual     Compl     Time
##    0   1.68862999e+05 -1.66862803e+05  1.50e+03 4.63e-07  9.99e+05     0s
##    1   3.32288030e+05 -3.31121401e+05  1.50e-03 4.55e-13  1.33e+05     0s
##    2   4.88215027e+04 -4.83744738e+04  1.50e-09 2.84e-14  1.94e+04     0s
##    3   7.20552197e+03 -7.03403484e+03  3.55e-14 1.42e-14  2.85e+03     0s
##    4   1.07582166e+03 -1.00982226e+03  1.78e-14 1.07e-14  4.17e+02     0s
##    5   1.65319400e+02 -1.39657698e+02  3.55e-15 3.55e-15  6.10e+01     0s
##    6   2.72141305e+01 -1.68504217e+01  1.33e-15 4.44e-16  8.81e+00     0s
##    7   5.34776479e+00 -4.13214640e-01  2.22e-16 2.22e-16  1.15e+00     0s
##    8   2.27046251e+00  2.04615758e+00  2.22e-16 4.44e-16  4.49e-02     0s
##    9   2.11217859e+00  2.11101837e+00  7.77e-15 1.67e-16  2.32e-04     0s
##   10   2.11111218e+00  2.11111102e+00  5.55e-16 3.29e-16  2.32e-07     0s
##   11   2.11111111e+00  2.11111111e+00  3.33e-15 3.33e-16  2.32e-10     0s
## 
## Barrier solved model in 11 iterations and 0.00 seconds
## Optimal objective 2.11111111e+00</code></pre>
<pre class="r"><code>print(result$objval)</code></pre>
<pre><code>## [1] 2.111111</code></pre>
<pre class="r"><code>print(result$x)</code></pre>
<pre><code>## [1] 3.584007e-10 1.000000e+00 6.666667e-01</code></pre>
<pre class="r"><code>model$vtype &lt;- c(&#39;I&#39;, &#39;I&#39;, &#39;I&#39;)

result &lt;- gurobi(model)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 2 rows, 3 columns and 5 nonzeros
## Model fingerprint: 0x2458258b
## Model has 5 quadratic objective terms
## Variable types: 0 continuous, 3 integer (0 binary)
## Coefficient statistics:
##   Matrix range     [1e+00, 3e+00]
##   Objective range  [2e+00, 2e+00]
##   QObjective range [2e+00, 2e+00]
##   Bounds range     [0e+00, 0e+00]
##   RHS range        [1e+00, 4e+00]
## Found heuristic solution: objective 2.000000e+19
## Presolve time: 0.00s
## Presolved: 2 rows, 3 columns, 5 nonzeros
## Presolved model has 5 quadratic objective terms
## Variable types: 0 continuous, 3 integer (0 binary)
## 
## Root relaxation: objective 2.111111e+00, 5 iterations, 0.00 seconds
## 
##     Nodes    |    Current Node    |     Objective Bounds      |     Work
##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time
## 
##      0     0    2.11111    0    1 2.0000e+19    2.11111   100%     -    0s
## H    0     0                       3.0000000    2.11111  29.6%     -    0s
##      0     0    2.11111    0    1    3.00000    2.11111  29.6%     -    0s
## 
## Explored 1 nodes (5 simplex iterations) in 0.00 seconds
## Thread count was 8 (of 8 available processors)
## 
## Solution count 2: 3 2e+19 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 3.000000000000e+00, best bound 3.000000000000e+00, gap 0.0000%</code></pre>
<pre class="r"><code>print(result$objval)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>print(result$x)</code></pre>
<pre><code>## [1] 0 1 1</code></pre>
<pre class="r"><code># Clear space
rm(model, result)</code></pre>
<p>This example formulates and solves the following simple QCP model:
<span class="math inline">\(max: x\)</span></p>
<p>subject to</p>
<p><span class="math inline">\(x + y + z = 1\)</span></p>
<p><span class="math inline">\(x^2 + y^2 \leq z^2\)</span> (second-order cone)
$ x^2 yz$ (rotated second-order cone)
x, y, z non-negative</p>
<pre class="r"><code>model &lt;- list()

model$A          &lt;- matrix(c(1,1,1), nrow=1, byrow=T)
model$modelsense &lt;- &#39;max&#39;
model$obj        &lt;- c(1,0,0)
model$rhs        &lt;- c(1)
model$sense      &lt;- c(&#39;=&#39;)

# First quadratic constraint: x^2 + y^2 - z^2 &lt;= 0
qc1 &lt;- list()
qc1$Qc &lt;- spMatrix(3, 3, c(1, 2, 3), c(1, 2, 3), c(1.0, 1.0, -1.0))
qc1$rhs &lt;- 0.0

# Second quadratic constraint: x^2 - yz &lt;= 0
qc2 &lt;- list()
qc2$Qc &lt;- spMatrix(3, 3, c(1, 2), c(1, 3), c(1.0, -1.0))
qc2$rhs &lt;- 0.0

model$quadcon &lt;- list(qc1, qc2)

result &lt;- gurobi(model)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 1 rows, 3 columns and 3 nonzeros
## Model fingerprint: 0x9bebabed
## Model has 2 quadratic constraints
## Coefficient statistics:
##   Matrix range     [1e+00, 1e+00]
##   QMatrix range    [1e+00, 1e+00]
##   Objective range  [1e+00, 1e+00]
##   Bounds range     [0e+00, 0e+00]
##   RHS range        [1e+00, 1e+00]
## Presolve time: 0.00s
## Presolved: 6 rows, 6 columns, 13 nonzeros
## Presolved model has 2 second-order cone constraints
## Ordering time: 0.00s
## 
## Barrier statistics:
##  AA&#39; NZ     : 1.500e+01
##  Factor NZ  : 2.100e+01
##  Factor Ops : 9.100e+01 (less than 1 second per iteration)
##  Threads    : 1
## 
##                   Objective                Residual
## Iter       Primal          Dual         Primal    Dual     Compl     Time
##    0   2.38095238e-01  2.38095238e-01  1.11e-16 4.33e-01  9.23e-02     0s
##    1   3.20481543e-01  3.62123302e-01  5.55e-17 1.39e-02  7.95e-03     0s
##    2   3.26649101e-01  3.28651430e-01  1.15e-14 5.44e-04  3.46e-04     0s
##    3   3.26797051e-01  3.27019441e-01  2.06e-13 5.98e-10  2.78e-05     0s
##    4   3.26990986e-01  3.26994814e-01  4.11e-13 3.45e-13  4.78e-07     0s
##    5   3.26992304e-01  3.26992876e-01  3.84e-11 2.82e-14  7.15e-08     0s
## 
## Barrier solved model in 5 iterations and 0.00 seconds
## Optimal objective 3.26992304e-01
## 
## Warning: to get QCP duals, please set parameter QCPDual to 1</code></pre>
<pre class="r"><code>print(result$objval)</code></pre>
<pre><code>## [1] 0.3269923</code></pre>
<pre class="r"><code>print(result$x)</code></pre>
<pre><code>## [1] 0.3269923 0.2570664 0.4159413</code></pre>
<pre class="r"><code># Clear space
rm(model, result)</code></pre>
<p>This example considers the following separable, convex problem:</p>
<p><span class="math inline">\(min: f(x) - y + g(z)\)</span></p>
<p>subject to</p>
<p><span class="math inline">\(x + 2 y + 3 z \leq 4\)</span>
<span class="math inline">\(x + y \geq 1\)</span>
<span class="math inline">\(x, y, z \geq 0\)</span></p>
<p>where <span class="math inline">\(f(u) = e^{-u} \text{ and} \: g(u) = 2 u^2 - 4u\: \forall \text{ real}\: u\)</span></p>
<p>It formulates and solves a simpler LP model by approximating f and
g with piecewise-linear functions. Then it transforms the model
into a MIP by negating the approximation for f, which gives
a non-convex piecewise-linear function, and solves it again.</p>
<pre class="r"><code>library(gurobi)

model &lt;- list()

model$A     &lt;- matrix(c(1,2,3,1,1,0), nrow=2, byrow=T)
model$obj   &lt;- c(0,-1,0)
model$ub    &lt;- c(1,1,1)
model$rhs   &lt;- c(4,1)
model$sense &lt;- c(&#39;&lt;&#39;, &#39;&gt;&#39;)

# Uniformly spaced points in [0.0, 1.0]
u &lt;- seq(from=0, to=1, by=0.01)

# First piecewise-linear function: f(x) = exp(-x)
pwl1     &lt;- list()
pwl1$var &lt;- 1
pwl1$x   &lt;- u
pwl1$y   &lt;- sapply(u, function(x) exp(-x))

# Second piecewise-linear function: g(z) = 2 z^2 - 4 z
pwl2     &lt;- list()
pwl2$var &lt;- 3
pwl2$x   &lt;- u
pwl2$y   &lt;- sapply(u, function(z) 2 * z * z - 4 * z)

model$pwlobj &lt;- list(pwl1, pwl2)

result &lt;- gurobi(model)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 2 rows, 3 columns and 5 nonzeros
## Model fingerprint: 0xc12b5aad
## Model has 2 piecewise-linear objective terms
## Coefficient statistics:
##   Matrix range     [1e+00, 3e+00]
##   Objective range  [1e+00, 1e+00]
##   Bounds range     [1e+00, 1e+00]
##   RHS range        [1e+00, 4e+00]
## Presolve time: 0.00s
## Presolved: 2 rows, 3 columns, 5 nonzeros
## 
## Iteration    Objective       Primal Inf.    Dual Inf.      Time
##        0   -2.6321206e+00   5.000000e-01   0.000000e+00      0s
##        2   -1.9346239e+00   0.000000e+00   0.000000e+00      0s
## 
## Solved in 2 iterations and 0.00 seconds
## Optimal objective -1.934623931e+00</code></pre>
<pre class="r"><code>print(result$objval)</code></pre>
<pre><code>## [1] -1.934624</code></pre>
<pre class="r"><code>print(result$x)</code></pre>
<pre><code>## [1] 0.690 0.725 0.620</code></pre>
<pre class="r"><code># Negate piecewise-linear function on x, making it non-convex

model$pwlobj[[1]]$y &lt;- sapply(u, function(x) -exp(-x))

result &lt;- gurobi(model)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 2 rows, 3 columns and 5 nonzeros
## Model fingerprint: 0x3229e670
## Model has 2 piecewise-linear objective terms
## Variable types: 3 continuous, 0 integer (0 binary)
## Coefficient statistics:
##   Matrix range     [1e+00, 3e+00]
##   Objective range  [1e+00, 1e+00]
##   Bounds range     [1e+00, 1e+00]
##   RHS range        [1e+00, 4e+00]
## Found heuristic solution: objective -1.3678794
## Presolve time: 0.00s
## Presolved: 202 rows, 302 columns, 603 nonzeros
## Variable types: 203 continuous, 99 integer (99 binary)
## 
## Root relaxation: objective -3.777733e+00, 1 iterations, 0.00 seconds
## 
##     Nodes    |    Current Node    |     Objective Bounds      |     Work
##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time
## 
## *    0     0               0      -3.7777333   -3.77773  0.00%     -    0s
## 
## Explored 0 nodes (1 simplex iterations) in 0.00 seconds
## Thread count was 8 (of 8 available processors)
## 
## Solution count 2: -3.77773 -1.36788 
## No other solutions better than -3.77773
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective -3.777733333333e+00, best bound -3.777733333333e+00, gap 0.0000%</code></pre>
<pre class="r"><code>gurobi_write(model, &quot;pwl.lp&quot;)</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>print(result$objval)</code></pre>
<pre><code>## [1] -3.777733</code></pre>
<pre class="r"><code>print(result$x)</code></pre>
<pre><code>## [1] 0.0000000 1.0000000 0.6666667</code></pre>
<pre class="r"><code># Clear space
rm(model, pwl1, pwl2, result)</code></pre>
<p>Want to cover three different sets but subject to a common budget of
elements allowed to be used. However, the sets have different priorities to
be covered; and we tackle this by using multi-objective optimization.</p>
<pre class="r"><code># define primitive data
groundSetSize     &lt;- 20
nSubSets          &lt;- 4
Budget            &lt;- 12
Set               &lt;- list(
    c( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
    c( 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 ),
    c( 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0 ),
    c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ) )
SetObjPriority    &lt;- c(3, 2, 2, 1)
SetObjWeight      &lt;- c(1.0, 0.25, 1.25, 1.0)

# Initialize model
model             &lt;- list()
model$modelsense  &lt;- &#39;max&#39;
model$modelname   &lt;- &#39;multiobj&#39;

# Set variables, all of them are binary, with 0,1 bounds.
model$vtype       &lt;- &#39;B&#39;
model$lb          &lt;- 0
model$ub          &lt;- 1
model$varnames    &lt;- paste(rep(&#39;El&#39;, groundSetSize), 1:groundSetSize, sep=&#39;&#39;)

# Build constraint matrix
model$A           &lt;- spMatrix(1, groundSetSize,
                              i = rep(1,groundSetSize),
                              j = 1:groundSetSize,
                              x = rep(1,groundSetSize))
model$rhs         &lt;- c(Budget)
model$sense       &lt;- c(&#39;&lt;&#39;)
model$constrnames &lt;- c(&#39;Budget&#39;)

# Set multi-objectives
model$multiobj          &lt;- list()
for (m in 1:nSubSets) {
  model$multiobj[[m]]          &lt;- list()
  model$multiobj[[m]]$objn     &lt;- Set[[m]]
  model$multiobj[[m]]$priority &lt;- SetObjPriority[m]
  model$multiobj[[m]]$weight   &lt;- SetObjWeight[m]
  model$multiobj[[m]]$abstol   &lt;- m
  model$multiobj[[m]]$reltol   &lt;- 0.01
  model$multiobj[[m]]$name     &lt;- sprintf(&#39;Set%d&#39;, m)
  model$multiobj[[m]]$con      &lt;- 0.0
}

# Save model
gurobi_write(model,&#39;multiobj_R.lp&#39;)</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code># Set parameters
params               &lt;- list()
params$PoolSolutions &lt;- 100

# Optimize
result &lt;- gurobi(model, params)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 1 rows, 20 columns and 20 nonzeros
## Model fingerprint: 0x28b3c9c7
## Variable types: 0 continuous, 20 integer (20 binary)
## Coefficient statistics:
##   Matrix range     [1e+00, 1e+00]
##   Objective range  [1e+00, 1e+00]
##   Bounds range     [1e+00, 1e+00]
##   RHS range        [1e+01, 1e+01]
## 
## ---------------------------------------------------------------------------
## Multi-objectives: starting optimization with 4 objectives (3 combined) ...
## ---------------------------------------------------------------------------
## 
## Multi-objectives: applying initial presolve ...
## ---------------------------------------------------------------------------
## 
## Presolve time: 0.00s
## Presolved: 1 rows and 20 columns
## ---------------------------------------------------------------------------
## 
## Multi-objectives: optimize objective 1 (Set1) ...
## ---------------------------------------------------------------------------
## 
## Found heuristic solution: objective 10.0000000
## 
## Explored 0 nodes (0 simplex iterations) in 0.00 seconds
## Thread count was 1 (of 8 available processors)
## 
## Solution count 1: 10 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 1.000000000000e+01, best bound 1.000000000000e+01, gap 0.0000%
## ---------------------------------------------------------------------------
## 
## Multi-objectives: optimize objective 2 (weighted) ...
## ---------------------------------------------------------------------------
## 
## 
## Loaded user MIP start with objective 6.25
## 
## Presolve removed 2 rows and 20 columns
## Presolve time: 0.00s
## Presolve: All rows and columns removed
## 
## Explored 0 nodes (0 simplex iterations) in 0.00 seconds
## Thread count was 1 (of 8 available processors)
## 
## Solution count 2: 10.5 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 1.050000000000e+01, best bound 1.050000000000e+01, gap 0.0000%
## ---------------------------------------------------------------------------
## 
## Multi-objectives: optimize objective 3 (Set4) ...
## ---------------------------------------------------------------------------
## 
## 
## Loaded user MIP start with objective 6
## 
## Presolve removed 3 rows and 20 columns
## Presolve time: 0.00s
## Presolve: All rows and columns removed
## 
## Explored 0 nodes (0 simplex iterations) in 0.00 seconds
## Thread count was 1 (of 8 available processors)
## 
## Solution count 2: 7 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 7.000000000000e+00, best bound 7.000000000000e+00, gap 0.0000%
## 
## ---------------------------------------------------------------------------
## Multi-objectives: solved in 0.00 seconds, solution count 3</code></pre>
<pre class="r"><code># Capture solution information
if (result$status != &#39;OPTIMAL&#39;) {
  cat(&#39;Optimization finished with status&#39;, result$status, &#39;\n&#39;)
  stop(&#39;Stop now\n&#39;)
}

# Print best solution
cat(&#39;Selected elements in best solution:\n&#39;)</code></pre>
<pre><code>## Selected elements in best solution:</code></pre>
<pre class="r"><code>for (e in 1:groundSetSize) {
  if(result$x[e] &lt; 0.9) next
  cat(&#39; El&#39;,e,sep=&#39;&#39;)
}</code></pre>
<pre><code>##  El2 El3 El4 El5 El6 El7 El8 El9 El10 El11 El12 El17</code></pre>
<pre class="r"><code>cat(&#39;\n&#39;)</code></pre>
<pre class="r"><code># Iterate over the best 10 solutions
if (&#39;pool&#39; %in% names(result)) {
  solcount &lt;- length(result$pool)
  cat(&#39;Number of solutions found:&#39;, solcount, &#39;\n&#39;)
  if (solcount &gt; 10) {
    solcount &lt;- 10
  }
  cat(&#39;Objective values for first&#39;, solcount, &#39;solutions:\n&#39;)
  for (k in 1:solcount) {
    cat(&#39;Solution&#39;, k, &#39;has objective:&#39;, result$pool[[k]]$objval[1], &#39;\n&#39;)
  }
} else {
  solcount &lt;- 1
  cat(&#39;Number of solutions found:&#39;, solcount, &#39;\n&#39;)
  cat(&#39;Solution 1 has objective:&#39;, result$objval, &#39;\n&#39;)
}</code></pre>
<pre><code>## Number of solutions found: 3 
## Objective values for first 3 solutions:
## Solution 1 has objective: 9 
## Solution 2 has objective: 9 
## Solution 3 has objective: 10</code></pre>
<pre class="r"><code># Clean up
rm(model, params, result)</code></pre>
<p>Assign workers to shifts; each worker may or may not be available on a
particular day. We use Pareto optimization to solve the model:
first, we minimize the linear sum of the slacks. Then, we constrain
the sum of the slacks, and we minimize a quadratic objective that
tries to balance the workload among the workers.</p>
<pre class="r"><code># define data
nShifts       &lt;- 14
nWorkers      &lt;-  7
nVars         &lt;- (nShifts + 1) * (nWorkers + 1) + nWorkers + 1
varIdx        &lt;- function(w,s) {s+(w-1)*nShifts}
shiftSlackIdx &lt;- function(s) {s+nShifts*nWorkers}
totShiftIdx   &lt;- function(w) {w + nShifts * (nWorkers+1)}
avgShiftIdx   &lt;- ((nShifts+1)*(nWorkers+1))
diffShiftIdx  &lt;- function(w) {w + avgShiftIdx}
totalSlackIdx &lt;- nVars


Shifts  &lt;- c(&#39;Mon1&#39;, &#39;Tue2&#39;, &#39;Wed3&#39;, &#39;Thu4&#39;, &#39;Fri5&#39;, &#39;Sat6&#39;, &#39;Sun7&#39;,
             &#39;Mon8&#39;, &#39;Tue9&#39;, &#39;Wed10&#39;, &#39;Thu11&#39;, &#39;Fri12&#39;, &#39;Sat13&#39;, &#39;Sun14&#39;)
Workers &lt;- c( &#39;Amy&#39;, &#39;Bob&#39;, &#39;Cathy&#39;, &#39;Dan&#39;, &#39;Ed&#39;, &#39;Fred&#39;, &#39;Gu&#39; )

shiftRequirements &lt;- c(3, 2, 4, 4, 5, 6, 5, 2, 2, 3, 4, 6, 7, 5 )

availability &lt;- list( c( 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1 ),
                      c( 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0 ),
                      c( 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 ),
                      c( 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1 ),
                      c( 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1 ),
                      c( 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1 ),
                      c( 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ) )

# Function to display results
solveandprint &lt;- function(model, env) {
  result &lt;- gurobi(model, env = env)
  if(result$status == &#39;OPTIMAL&#39;) {
    cat(&#39;The optimal objective is&#39;,result$objval,&#39;\n&#39;)
    cat(&#39;Schedule:\n&#39;)
    for (s in 1:nShifts) {
      cat(&#39;\t&#39;,Shifts[s],&#39;:&#39;)
      for (w in 1:nWorkers) {
        if (result$x[varIdx(w,s)] &gt; 0.9) cat(Workers[w],&#39; &#39;)
      }
      cat(&#39;\n&#39;)
    }
    cat(&#39;Workload:\n&#39;)
    for (w in 1:nWorkers) {
      cat(&#39;\t&#39;,Workers[w],&#39;:&#39;,result$x[totShiftIdx(w)],&#39;\n&#39;)
    }
  } else {
    cat(&#39;Optimization finished with status&#39;,result$status)
  }
  result
}

# Set-up environment
env &lt;- list()
env$logfile &lt;- &#39;workforce4.log&#39;

# Build model
model            &lt;- list()
model$modelname  &lt;- &#39;workforce4&#39;
model$modelsense &lt;- &#39;min&#39;

# Initialize assignment decision variables:
#    x[w][s] == 1 if worker w is assigned to shift s.
#    This is no longer a pure assignment model, so we must
#    use binary variables.
model$vtype    &lt;- rep(&#39;C&#39;, nVars)
model$lb       &lt;- rep(0, nVars)
model$ub       &lt;- rep(1, nVars)
model$obj      &lt;- rep(0, nVars)
model$varnames &lt;- rep(&#39;&#39;,nVars)
for (w in 1:nWorkers) {
  for (s in 1:nShifts) {
    model$vtype[varIdx(w,s)]    = &#39;B&#39;
    model$varnames[varIdx(w,s)] = paste0(Workers[w],&#39;.&#39;,Shifts[s])
    if (availability[[w]][s] == 0) model$ub[varIdx(w,s)] = 0
  }
}

# Initialize shift slack variables
for (s in 1:nShifts) {
  model$varnames[shiftSlackIdx(s)] = paste0(&#39;ShiftSlack&#39;,Shifts[s])
  model$ub[shiftSlackIdx(s)] = Inf
}

# Initialize worker slack and diff variables
for (w in 1:nWorkers) {
  model$varnames[totShiftIdx(w)] = paste0(&#39;TotalShifts&#39;,Workers[w])
  model$ub[totShiftIdx(w)]       = Inf
  model$varnames[diffShiftIdx(w)]  = paste0(&#39;DiffShifts&#39;,Workers[w])
  model$ub[diffShiftIdx(w)]        = Inf
  model$lb[diffShiftIdx(w)]        = -Inf
}

#Initialize average shift variable
model$ub[avgShiftIdx]      = Inf
model$varnames[avgShiftIdx] = &#39;AvgShift&#39;

#Initialize total slack variable
model$ub[totalSlackIdx]      = Inf
model$varnames[totalSlackIdx] = &#39;TotalSlack&#39;
model$obj[totalSlackIdx]     = 1

# Set-up shift-requirements constraints
model$A           &lt;- spMatrix(nShifts,nVars,
                      i = c(c(mapply(rep,1:nShifts,nWorkers)),
                            c(1:nShifts)),
                      j = c(mapply(varIdx,1:nWorkers,
                                 mapply(rep,1:nShifts,nWorkers)),
                            shiftSlackIdx(1:nShifts)),
                      x = rep(1,nShifts * (nWorkers+1)))
model$sense       &lt;- rep(&#39;=&#39;,nShifts)
model$rhs         &lt;- shiftRequirements
model$constrnames &lt;- Shifts

# Set TotalSlack equal to the sum of each shift slack
B &lt;- spMatrix(1, nVars,
        i = rep(1,nShifts+1),
        j = c(shiftSlackIdx(1:nShifts),totalSlackIdx),
        x = c(rep(1,nShifts),-1))
model$A           &lt;- rbind(model$A, B)
model$rhs         &lt;- c(model$rhs,0)
model$sense       &lt;- c(model$sense,&#39;=&#39;)
model$constrnames &lt;- c(model$constrnames, &#39;TotalSlack&#39;)

# Set total number of shifts for each worker
B &lt;- spMatrix(nWorkers, nVars,
          i = c(mapply(rep,1:nWorkers,nShifts),
                1:nWorkers),
          j = c(mapply(varIdx,c(mapply(rep,1:nWorkers,nShifts)),1:nShifts),
                totShiftIdx(1:nWorkers)),
          x = c(rep(1,nShifts*nWorkers),rep(-1,nWorkers)))
model$A           &lt;- rbind(model$A, B)
model$rhs         &lt;- c(model$rhs,rep(0,nWorkers))
model$sense       &lt;- c(model$sense,rep(&#39;=&#39;,nWorkers))
model$constrnames &lt;- c(model$constrnames, sprintf(&#39;TotalShifts%s&#39;,Workers[1:nWorkers]))

# Save initial model
gurobi_write(model,&#39;workforce4.lp&#39;, env)</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code># Optimize
result &lt;- solveandprint(model, env)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 22 rows, 128 columns and 232 nonzeros
## Model fingerprint: 0x78ab1a9c
## Variable types: 30 continuous, 98 integer (98 binary)
## Coefficient statistics:
##   Matrix range     [1e+00, 1e+00]
##   Objective range  [1e+00, 1e+00]
##   Bounds range     [1e+00, 1e+00]
##   RHS range        [2e+00, 7e+00]
## Found heuristic solution: objective 58.0000000
## Presolve removed 22 rows and 128 columns
## Presolve time: 0.00s
## Presolve: All rows and columns removed
## 
## Explored 0 nodes (0 simplex iterations) in 0.00 seconds
## Thread count was 1 (of 8 available processors)
## 
## Solution count 2: 6 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 6.000000000000e+00, best bound 6.000000000000e+00, gap 0.0000%
## The optimal objective is 6 
## Schedule:
##   Mon1 :Bob  Fred  Gu  
##   Tue2 :Amy  Ed  
##   Wed3 :Amy  Cathy  Fred  Gu  
##   Thu4 :Cathy  Ed  
##   Fri5 :Amy  Bob  Cathy  Ed  Gu  
##   Sat6 :Bob  Dan  Fred  Gu  
##   Sun7 :Amy  Cathy  Ed  Gu  
##   Mon8 :Fred  Gu  
##   Tue9 :Amy  Ed  
##   Wed10 :Amy  Cathy  Gu  
##   Thu11 :Amy  Dan  Ed  Gu  
##   Fri12 :Amy  Cathy  Dan  Fred  Gu  
##   Sat13 :Amy  Bob  Cathy  Dan  Ed  Fred  Gu  
##   Sun14 :Amy  Cathy  Dan  Fred  Gu  
## Workload:
##   Amy : 10 
##   Bob : 4 
##   Cathy : 8 
##   Dan : 5 
##   Ed : 7 
##   Fred : 7 
##   Gu : 11</code></pre>
<pre class="r"><code>if (result$status != &#39;OPTIMAL&#39;) stop(&#39;Stop now\n&#39;)

# Constraint the slack by setting its upper and lower bounds
totalSlack &lt;- result$x[totalSlackIdx]
model$lb[totalSlackIdx] = totalSlack
model$ub[totalSlackIdx] = totalSlack

# Link average number of shifts worked and difference with average
B &lt;- spMatrix(nWorkers+1, nVars,
        i = c(1:nWorkers,
              1:nWorkers,
              1:nWorkers,
              rep(nWorkers+1,nWorkers+1)),
        j = c(totShiftIdx(1:nWorkers),
              diffShiftIdx(1:nWorkers),
              rep(avgShiftIdx,nWorkers),
              totShiftIdx(1:nWorkers),avgShiftIdx),
        x = c(rep(1, nWorkers),
              rep(-1,nWorkers),
              rep(-1,nWorkers),
              rep(1,nWorkers),-nWorkers))
model$A           &lt;- rbind(model$A, B)
model$rhs         &lt;- c(model$rhs,rep(0,nWorkers+1))
model$sense       &lt;- c(model$sense,rep(&#39;=&#39;,nWorkers+1))
model$constrnames &lt;- c(model$constrnames,
                       sprintf(&#39;DiffShifts%s&#39;,Workers[1:nWorkers]),
                       &#39;AvgShift&#39;)

# Objective: minimize the sum of the square of the difference from the
# average number of shifts worked
model$obj &lt;- 0
model$Q   &lt;- spMatrix(nVars,nVars,
                i = c(diffShiftIdx(1:nWorkers)),
                j = c(diffShiftIdx(1:nWorkers)),
                x = rep(1,nWorkers))

# Save modified model
gurobi_write(model,&#39;workforce4b.lp&#39;, env)</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code># Optimize
result &lt;- solveandprint(model, env)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 30 rows, 128 columns and 261 nonzeros
## Model fingerprint: 0x377bf6f1
## Model has 7 quadratic objective terms
## Variable types: 30 continuous, 98 integer (98 binary)
## Coefficient statistics:
##   Matrix range     [1e+00, 7e+00]
##   Objective range  [0e+00, 0e+00]
##   QObjective range [2e+00, 2e+00]
##   Bounds range     [1e+00, 6e+00]
##   RHS range        [2e+00, 7e+00]
## Found heuristic solution: objective 37.7142857
## Presolve removed 6 rows and 63 columns
## Presolve time: 0.00s
## Presolved: 24 rows, 65 columns, 136 nonzeros
## Presolved model has 7 quadratic objective terms
## Variable types: 7 continuous, 58 integer (50 binary)
## 
## Root relaxation: objective 2.142857e-01, 219 iterations, 0.00 seconds
## 
##     Nodes    |    Current Node    |     Objective Bounds      |     Work
##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time
## 
## H    0     0                      25.7142857    0.00000   100%     -    0s
##      0     0    0.21429    0   12   25.71429    0.21429  99.2%     -    0s
## H    0     0                       3.7142857    0.21429  94.2%     -    0s
## H    0     0                       1.7142857    0.21429  87.5%     -    0s
##      0     0    0.21429    0   12    1.71429    0.21429  87.5%     -    0s
##      0     2    0.21429    0   12    1.71429    0.21429  87.5%     -    0s
## 
## Explored 19 nodes (273 simplex iterations) in 0.04 seconds
## Thread count was 8 (of 8 available processors)
## 
## Solution count 4: 1.71429 3.71429 25.7143 37.7143 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 1.714285714286e+00, best bound 1.714285714286e+00, gap 0.0000%
## The optimal objective is 1.714286 
## Schedule:
##   Mon1 :Bob  Ed  Fred  
##   Tue2 :Bob  Fred  
##   Wed3 :Amy  Cathy  Dan  Ed  
##   Thu4 :Cathy  Ed  
##   Fri5 :Bob  Cathy  Dan  Ed  Gu  
##   Sat6 :Bob  Dan  Fred  Gu  
##   Sun7 :Amy  Cathy  Ed  Gu  
##   Mon8 :Bob  Cathy  
##   Tue9 :Amy  Fred  
##   Wed10 :Amy  Dan  Gu  
##   Thu11 :Bob  Dan  Ed  Gu  
##   Fri12 :Amy  Cathy  Dan  Fred  Gu  
##   Sat13 :Amy  Bob  Cathy  Dan  Ed  Fred  Gu  
##   Sun14 :Amy  Cathy  Ed  Fred  Gu  
## Workload:
##   Amy : 7 
##   Bob : 7 
##   Cathy : 8 
##   Dan : 7 
##   Ed : 8 
##   Fred : 7 
##   Gu : 8</code></pre>
<pre class="r"><code>if (result$status != &#39;OPTIMAL&#39;) stop(&#39;Stop now\n&#39;)

#Clear space
rm(model, env, availability, Shifts, Workers, shiftRequirements, result)</code></pre>
<pre class="r"><code># Assign workers to shifts; each worker may or may not be available on a
# particular day. We use multi-objective optimization to solve the model.
# The highest-priority objective minimizes the sum of the slacks
# (i.e., the total number of uncovered shifts). The secondary objective
# minimizes the difference between the maximum and minimum number of
# shifts worked among all workers.  The second optimization is allowed
# to degrade the first objective by up to the smaller value of 10% and 2



# define data
nShifts       &lt;- 14
nWorkers      &lt;-  8
nVars         &lt;- (nShifts + 1) * (nWorkers + 1) + 2
varIdx        &lt;- function(w,s) {s+(w-1)*nShifts}
shiftSlackIdx &lt;- function(s) {s+nShifts*nWorkers}
totShiftIdx   &lt;- function(w) {w + nShifts * (nWorkers+1)}
minShiftIdx   &lt;- ((nShifts+1)*(nWorkers+1))
maxShiftIdx   &lt;- (minShiftIdx+1)
totalSlackIdx &lt;- nVars


Shifts  &lt;- c(&#39;Mon1&#39;, &#39;Tue2&#39;, &#39;Wed3&#39;, &#39;Thu4&#39;, &#39;Fri5&#39;, &#39;Sat6&#39;, &#39;Sun7&#39;,
             &#39;Mon8&#39;, &#39;Tue9&#39;, &#39;Wed10&#39;, &#39;Thu11&#39;, &#39;Fri12&#39;, &#39;Sat13&#39;, &#39;Sun14&#39;)
Workers &lt;- c( &#39;Amy&#39;, &#39;Bob&#39;, &#39;Cathy&#39;, &#39;Dan&#39;, &#39;Ed&#39;, &#39;Fred&#39;, &#39;Gu&#39;, &#39;Tobi&#39; )

shiftRequirements &lt;- c(3, 2, 4, 4, 5, 6, 5, 2, 2, 3, 4, 6, 7, 5 )

availability &lt;- list( c( 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1 ),
                      c( 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0 ),
                      c( 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 ),
                      c( 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1 ),
                      c( 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1 ),
                      c( 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1 ),
                      c( 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1 ),
                      c( 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ) )

# Function to display results
solveandprint &lt;- function(model, env) {
  result &lt;- gurobi(model, env = env)
  if(result$status == &#39;OPTIMAL&#39;) {
    cat(&#39;The optimal objective is&#39;,result$objval,&#39;\n&#39;)
    cat(&#39;Schedule:\n&#39;)
    for (s in 1:nShifts) {
      cat(&#39;\t&#39;,Shifts[s],&#39;:&#39;)
      for (w in 1:nWorkers) {
        if (result$x[varIdx(w,s)] &gt; 0.9) cat(Workers[w],&#39; &#39;)
      }
      cat(&#39;\n&#39;)
    }
    cat(&#39;Workload:\n&#39;)
    for (w in 1:nWorkers) {
      cat(&#39;\t&#39;,Workers[w],&#39;:&#39;,result$x[totShiftIdx(w)],&#39;\n&#39;)
    }
  } else {
    cat(&#39;Optimization finished with status&#39;,result$status)
  }
  result
}

# Set-up environment
env &lt;- list()
env$logfile &lt;- &#39;workforce5.log&#39;

# Build model
model            &lt;- list()
model$modelname  &lt;- &#39;workforce5&#39;
model$modelsense &lt;- &#39;min&#39;

# Initialize assignment decision variables:
#    x[w][s] == 1 if worker w is assigned to shift s.
#    This is no longer a pure assignment model, so we must
#    use binary variables.
model$vtype    &lt;- rep(&#39;C&#39;, nVars)
model$lb       &lt;- rep(0, nVars)
model$ub       &lt;- rep(1, nVars)
model$varnames &lt;- rep(&#39;&#39;,nVars)
for (w in 1:nWorkers) {
  for (s in 1:nShifts) {
    model$vtype[varIdx(w,s)]    = &#39;B&#39;
    model$varnames[varIdx(w,s)] = paste0(Workers[w],&#39;.&#39;,Shifts[s])
    if (availability[[w]][s] == 0) model$ub[varIdx(w,s)] = 0
  }
}

# Initialize shift slack variables
for (s in 1:nShifts) {
  model$varnames[shiftSlackIdx(s)] = paste0(&#39;ShiftSlack&#39;,Shifts[s])
  model$ub[shiftSlackIdx(s)] = Inf
}

# Initialize worker slack and diff variables
for (w in 1:nWorkers) {
  model$varnames[totShiftIdx(w)] = paste0(&#39;TotalShifts&#39;,Workers[w])
  model$ub[totShiftIdx(w)]       = Inf
}

#Initialize min/max shift variables
model$ub[minShiftIdx]       = Inf
model$varnames[minShiftIdx] = &#39;MinShift&#39;
model$ub[maxShiftIdx]       = Inf
model$varnames[maxShiftIdx] = &#39;MaxShift&#39;

#Initialize total slack variable
model$ub[totalSlackIdx]      = Inf
model$varnames[totalSlackIdx] = &#39;TotalSlack&#39;

# Set-up shift-requirements constraints
model$A           &lt;- spMatrix(nShifts,nVars,
                      i = c(c(mapply(rep,1:nShifts,nWorkers)),
                            c(1:nShifts)),
                      j = c(mapply(varIdx,1:nWorkers,
                                 mapply(rep,1:nShifts,nWorkers)),
                            shiftSlackIdx(1:nShifts)),
                      x = rep(1,nShifts * (nWorkers+1)))
model$sense       &lt;- rep(&#39;=&#39;,nShifts)
model$rhs         &lt;- shiftRequirements
model$constrnames &lt;- Shifts

# Set TotalSlack equal to the sum of each shift slack
B &lt;- spMatrix(1, nVars,
        i = rep(1,nShifts+1),
        j = c(shiftSlackIdx(1:nShifts),totalSlackIdx),
        x = c(rep(1,nShifts),-1))
model$A           &lt;- rbind(model$A, B)
model$rhs         &lt;- c(model$rhs,0)
model$sense       &lt;- c(model$sense,&#39;=&#39;)
model$constrnames &lt;- c(model$constrnames, &#39;TotalSlack&#39;)

# Set total number of shifts for each worker
B &lt;- spMatrix(nWorkers, nVars,
          i = c(mapply(rep,1:nWorkers,nShifts),
                1:nWorkers),
          j = c(mapply(varIdx,c(mapply(rep,1:nWorkers,nShifts)),1:nShifts),
                totShiftIdx(1:nWorkers)),
          x = c(rep(1,nShifts*nWorkers),rep(-1,nWorkers)))
model$A           &lt;- rbind(model$A, B)
model$rhs         &lt;- c(model$rhs,rep(0,nWorkers))
model$sense       &lt;- c(model$sense,rep(&#39;=&#39;,nWorkers))
model$constrnames &lt;- c(model$constrnames, sprintf(&#39;TotalShifts%s&#39;,Workers[1:nWorkers]))

# Set minShift / maxShift general constraints
model$genconmin &lt;- list(list(resvar = minShiftIdx,
                             vars   = c(totShiftIdx(1:nWorkers)),
                             name   = &#39;MinShift&#39;))
model$genconmax &lt;- list(list(resvar = maxShiftIdx,
                             vars   = c(totShiftIdx(1:nWorkers)),
                             name   = &#39;MaxShift&#39;))

# Set multiobjective
model$multiobj &lt;- list(1:2)
model$multiobj[[1]]          &lt;- list()
model$multiobj[[1]]$objn     &lt;- c(rep(0,nVars))
model$multiobj[[1]]$objn[totalSlackIdx] = 1
model$multiobj[[1]]$priority &lt;- 2
model$multiobj[[1]]$weight   &lt;- 1
model$multiobj[[1]]$abstol   &lt;- 2
model$multiobj[[1]]$reltol   &lt;- 0.1
model$multiobj[[1]]$name     &lt;- &#39;TotalSlack&#39;
model$multiobj[[1]]$con      &lt;- 0.0
model$multiobj[[2]]          &lt;- list()
model$multiobj[[2]]$objn     &lt;- c(rep(0,nVars))
model$multiobj[[2]]$objn[minShiftIdx] = -1
model$multiobj[[2]]$objn[maxShiftIdx] =  1
model$multiobj[[2]]$priority &lt;- 1
model$multiobj[[2]]$weight   &lt;- 1
model$multiobj[[2]]$abstol   &lt;- 0
model$multiobj[[2]]$reltol   &lt;- 0
model$multiobj[[2]]$name     &lt;- &#39;Fairness&#39;
model$multiobj[[2]]$con      &lt;- 0.0


# Save initial model
gurobi_write(model,&#39;workforce5.lp&#39;, env)</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code># Optimize
result &lt;- solveandprint(model, env)</code></pre>
<pre><code>## Gurobi Optimizer version 9.0.3 build v9.0.3rc0 (win64)
## Optimize a model with 23 rows, 137 columns and 261 nonzeros
## Model fingerprint: 0xd347a5b4
## Model has 2 general constraints
## Variable types: 25 continuous, 112 integer (112 binary)
## Coefficient statistics:
##   Matrix range     [1e+00, 1e+00]
##   Objective range  [1e+00, 1e+00]
##   Bounds range     [1e+00, 1e+00]
##   RHS range        [2e+00, 7e+00]
## 
## ---------------------------------------------------------------------------
## Multi-objectives: starting optimization with 2 objectives ... 
## ---------------------------------------------------------------------------
## 
## Multi-objectives: applying initial presolve ...
## ---------------------------------------------------------------------------
## 
## Presolve added 13 rows and 0 columns
## Presolve removed 0 rows and 3 columns
## Presolve time: 0.00s
## Presolved: 36 rows and 134 columns
## ---------------------------------------------------------------------------
## 
## Multi-objectives: optimize objective 1 (TotalSlack) ...
## ---------------------------------------------------------------------------
## 
## Presolve added 8 rows and 0 columns
## Presolve removed 0 rows and 20 columns
## Presolve time: 0.00s
## Presolved: 44 rows, 114 columns, 224 nonzeros
## Presolved model has 8 SOS constraint(s)
## Variable types: 18 continuous, 96 integer (81 binary)
## Found heuristic solution: objective 7.0000000
## Found heuristic solution: objective 6.0000000
## 
## Root relaxation: objective 3.000000e+00, 30 iterations, 0.00 seconds
## 
##     Nodes    |    Current Node    |     Objective Bounds      |     Work
##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time
## 
##      0     0    3.00000    0    4    6.00000    3.00000  50.0%     -    0s
## H    0     0                       3.0000000    3.00000  0.00%     -    0s
##      0     0    3.00000    0    4    3.00000    3.00000  0.00%     -    0s
## 
## Explored 1 nodes (30 simplex iterations) in 0.01 seconds
## Thread count was 8 (of 8 available processors)
## 
## Solution count 3: 3 6 7 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 3.000000000000e+00, best bound 3.000000000000e+00, gap 0.0000%
## ---------------------------------------------------------------------------
## 
## Multi-objectives: optimize objective 2 (Fairness) ...
## ---------------------------------------------------------------------------
## 
## 
## Loaded user MIP start with objective 4
## 
## Presolve added 8 rows and 0 columns
## Presolve removed 0 rows and 10 columns
## Presolve time: 0.00s
## Presolved: 45 rows, 124 columns, 273 nonzeros
## Presolved model has 8 SOS constraint(s)
## Variable types: 18 continuous, 106 integer (81 binary)
## 
## Root relaxation: objective 0.000000e+00, 60 iterations, 0.00 seconds
## 
##     Nodes    |    Current Node    |     Objective Bounds      |     Work
##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time
## 
##      0     0    0.00000    0   19    4.00000    0.00000   100%     -    0s
## H    0     0                       1.0000000    0.00000   100%     -    0s
##      0     0    0.14286    0   21    1.00000    0.14286  85.7%     -    0s
##      0     0    0.14286    0   18    1.00000    0.14286  85.7%     -    0s
##      0     0    0.14286    0   16    1.00000    0.14286  85.7%     -    0s
##      0     2    0.14286    0   16    1.00000    0.14286  85.7%     -    0s
## 
## Explored 1213 nodes (4042 simplex iterations) in 0.16 seconds
## Thread count was 8 (of 8 available processors)
## 
## Solution count 3: 1 1 4 
## 
## Optimal solution found (tolerance 1.00e-04)
## Best objective 1.000000000000e+00, best bound 1.000000000000e+00, gap 0.0000%
## 
## ---------------------------------------------------------------------------
## Multi-objectives: solved in 0.17 seconds, solution count 5
## 
## The optimal objective is 4 1 
## Schedule:
##   Mon1 :Bob  Ed  Fred  
##   Tue2 :Amy  Bob  
##   Wed3 :Amy  Dan  Gu  Tobi  
##   Thu4 :Cathy  Ed  Gu  
##   Fri5 :Amy  Bob  Cathy  Dan  Ed  
##   Sat6 :Bob  Dan  Fred  Gu  Tobi  
##   Sun7 :Amy  Cathy  Ed  Gu  Tobi  
##   Mon8 :Ed  Fred  
##   Tue9 :Cathy  Fred  
##   Wed10 :Cathy  Dan  Gu  
##   Thu11 :Bob  Cathy  Gu  Tobi  
##   Fri12 :Amy  Cathy  Dan  Fred  Tobi  
##   Sat13 :Amy  Bob  Dan  Ed  Fred  Tobi  
##   Sun14 :Amy  Dan  Ed  Fred  Gu  
## Workload:
##   Amy : 7 
##   Bob : 6 
##   Cathy : 7 
##   Dan : 7 
##   Ed : 7 
##   Fred : 7 
##   Gu : 7 
##   Tobi : 6</code></pre>
<pre class="r"><code>if (result$status != &#39;OPTIMAL&#39;) stop(&#39;Stop now\n&#39;)

#Clear space
rm(model, env, availability, Shifts, Workers, shiftRequirements, result)</code></pre>
<p>Add a new chunk by clicking the <em>Insert Chunk</em> button on the toolbar or by pressing <em>Ctrl+Alt+I</em>.</p>
<p>When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the <em>Preview</em> button or press <em>Ctrl+Shift+K</em> to preview the HTML file).</p>
<p>The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike <em>Knit</em>, <em>Preview</em> does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.</p>

        
        <details closed class="f6 fw7 input-reset">
  <dl class="f6 lh-copy">
    <dt class="fw7">Posted on:</dt>
    <dd class="fw5 ml0">January 6, 2020</dd>
  </dl>
  <dl class="f6 lh-copy">
    <dt class="fw7">Length:</dt>
    <dd class="fw5 ml0">24 minute read, 5086 words</dd>
  </dl>
  
  <dl class="f6 lh-copy">
    <dt class="fw7">Categories:</dt>
    <dd class="fw5 ml0"> <a href="/categories/orie-techniques">ORIE Techniques</a> </dd>
  </dl>
  
  
  
  <dl class="f6 lh-copy">
    <dt class="fw7">Tags:</dt>
    <dd class="fw5 ml0"> <a href="/tags/r-markdown">R Markdown</a>  <a href="/tags/qp">QP</a>  <a href="/tags/gurboi">Gurboi</a>  <a href="/tags/algorithms">Algorithms</a> </dd>
  </dl>
  
  <dl class="f6 lh-copy">
    <dt class="fw7">See Also:</dt>
    
    <dd class="fw5 ml0"><a href="/blog/orie/decompo_algs/">Decompositions Algorithms Broken Down and Explained</a></dd>
    
    <dd class="fw5 ml0"><a href="/blog/orie/benders/">Benders Decomposition Algorithm Explained</a></dd>
    
    <dd class="fw5 ml0"><a href="/blog/orie/qp_algorithms/">Quadratic Programming Examples and Algorithms</a></dd>
    
  </dl>
</details>

      </section>
      <footer class="post-footer">
        <div class="post-pagination dt w-100 mt4 mb2">
  
  
    <a class="prev dtc pr2 tl v-top fw6"
    href="/blog/orie/qp_algorithms/">&larr; Quadratic Programming Examples and Algorithms</a>
  
  
  
    <a class="next dtc pl2 tr v-top fw6"
    href="/blog/orie/gurobi_examples/">Gurobi Basic LP/MIP Examples &rarr;</a>
  
</div>

      </footer>
    </article>
    
      
<div class="post-comments pa0 pa4-l mt4">
  
  <script src="https://utteranc.es/client.js"
          repo="apreshill/apero"
          issue-term="pathname"
          theme="boxy-light"
          label="comments :crystal_ball:"
          crossorigin="anonymous"
          async
          type="text/javascript">
  </script>
  
</div>

    
  </section>
</main>
<footer class="site-footer pv4 bt b--transparent ph5" role="contentinfo">
  <nav class="db dt-l w-100">
    <p class="site-copyright f7 db dtc-l v-mid w-100 w-33-l tc tl-l pv2 pv0-l mv0 lh-copy">
      &copy; 2022 Erick Jones, Texas
      <span class="middot-divider"></span>
      Made with <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"><a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/hugo-apero/" rel="dct:source">Hugo Apéro</a></span>.
      <br />
      
Based on <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"><a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/formspree/blogophonic-hugo" rel="dct:source">Blogophonic</a></span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://formspree.io" property="cc:attributionName" rel="cc:attributionURL">Formspree</a>.
    </p>
    
    <div class="site-links f6 db dtc-l v-mid w-100 w-67-l tc tr-l pv2 pv0-l mv0">
      
    </div>
  </nav>
  
    <script>

    var i, text, code, codes = document.getElementsByTagName('code');
    for (let i = 0; i < codes.length;) {
      code = codes[i];
      if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
        text = code.textContent;
        if (/^\$[^$]/.test(text) && /[^$]\$$/.test(text)) {
          text = text.replace(/^\$/, '\\(').replace(/\$$/, '\\)');
          code.textContent = text;
        }
        if (/^\\\((.|\s)+\\\)$/.test(text) ||
            /^\\\[(.|\s)+\\\]$/.test(text) ||
            /^\$(.|\s)+\$$/.test(text) ||
            /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
          code.outerHTML = code.innerHTML;  
          continue;
        }
      }
      i++;
    }
</script>

  
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>



    
  
  
</footer>

      </div>
    </body>
</html>
